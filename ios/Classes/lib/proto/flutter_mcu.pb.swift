// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: lib/proto/flutter_mcu.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// package no.nordicsemi.android.mcumgr_flutter.gen;

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Flutter call arguments
struct ProtoUpdateCallArgument {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceUuid: String = String()

  var firmwareData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ProtoError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var localizedDescription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Firmware image pair
struct Pair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Int32 = 0

  var value: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ProtoUpdateWithImageCallArguments {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceUuid: String = String()

  var images: [Pair] = []

  var configuration: ProtoFirmwareUpgradeConfiguration {
    get {return _configuration ?? ProtoFirmwareUpgradeConfiguration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _configuration: ProtoFirmwareUpgradeConfiguration? = nil
}

/// STATE
struct ProtoUpdateStateChangesStreamArg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var done: Bool = false

  var error: ProtoError {
    get {return _error ?? ProtoError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var updateStateChanges: ProtoUpdateStateChanges {
    get {return _updateStateChanges ?? ProtoUpdateStateChanges()}
    set {_updateStateChanges = newValue}
  }
  /// Returns true if `updateStateChanges` has been explicitly set.
  var hasUpdateStateChanges: Bool {return self._updateStateChanges != nil}
  /// Clears the value of `updateStateChanges`. Subsequent reads from it will return its default value.
  mutating func clearUpdateStateChanges() {self._updateStateChanges = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: ProtoError? = nil
  fileprivate var _updateStateChanges: ProtoUpdateStateChanges? = nil
}

struct ProtoUpdateStateChanges {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oldState: ProtoUpdateStateChanges.FirmwareUpgradeState = .none

  var newState: ProtoUpdateStateChanges.FirmwareUpgradeState = .none

  var canceled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FirmwareUpgradeState: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case none // = 0
    case validate // = 1
    case upload // = 2
    case test // = 3
    case reset // = 4
    case confirm // = 5
    case success // = 6
    case requestMcuMgrParameters // = 7
    case eraseAppSettings // = 8
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .validate
      case 2: self = .upload
      case 3: self = .test
      case 4: self = .reset
      case 5: self = .confirm
      case 6: self = .success
      case 7: self = .requestMcuMgrParameters
      case 8: self = .eraseAppSettings
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .validate: return 1
      case .upload: return 2
      case .test: return 3
      case .reset: return 4
      case .confirm: return 5
      case .success: return 6
      case .requestMcuMgrParameters: return 7
      case .eraseAppSettings: return 8
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ProtoUpdateStateChanges.FirmwareUpgradeState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ProtoUpdateStateChanges.FirmwareUpgradeState] = [
    .none,
    .validate,
    .upload,
    .test,
    .reset,
    .confirm,
    .success,
    .requestMcuMgrParameters,
    .eraseAppSettings,
  ]
}

#endif  // swift(>=4.2)

struct ProtoFirmwareUpgradeConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var estimatedSwapTimeMs: Int64 = 0

  var eraseAppSettings: Bool = false

  var pipelineDepth: Int64 = 0

  var byteAlignment: ProtoFirmwareUpgradeConfiguration.ImageUploadAlignment = .disabled

  var reassemblyBufferSize: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ImageUploadAlignment: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case disabled // = 0
    case twoByte // = 1
    case fourByte // = 2
    case eightByte // = 3
    case sixteenByte // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .disabled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .disabled
      case 1: self = .twoByte
      case 2: self = .fourByte
      case 3: self = .eightByte
      case 4: self = .sixteenByte
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .disabled: return 0
      case .twoByte: return 1
      case .fourByte: return 2
      case .eightByte: return 3
      case .sixteenByte: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ProtoFirmwareUpgradeConfiguration.ImageUploadAlignment: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ProtoFirmwareUpgradeConfiguration.ImageUploadAlignment] = [
    .disabled,
    .twoByte,
    .fourByte,
    .eightByte,
    .sixteenByte,
  ]
}

#endif  // swift(>=4.2)

struct ProtoProgressUpdateStreamArg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var done: Bool = false

  var error: ProtoError {
    get {return _error ?? ProtoError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var progressUpdate: ProtoProgressUpdate {
    get {return _progressUpdate ?? ProtoProgressUpdate()}
    set {_progressUpdate = newValue}
  }
  /// Returns true if `progressUpdate` has been explicitly set.
  var hasProgressUpdate: Bool {return self._progressUpdate != nil}
  /// Clears the value of `progressUpdate`. Subsequent reads from it will return its default value.
  mutating func clearProgressUpdate() {self._progressUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: ProtoError? = nil
  fileprivate var _progressUpdate: ProtoProgressUpdate? = nil
}

struct ProtoProgressUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bytesSent: UInt64 = 0

  var imageSize: UInt64 = 0

  var timestamp: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LOGS
struct ProtoLogMessageStreamArg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var done: Bool = false

  var error: ProtoError {
    get {return _error ?? ProtoError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var protoLogMessage: [ProtoLogMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: ProtoError? = nil
}

struct ProtoLogMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var logCategory: ProtoLogMessage.LogCategory = .transport

  var logLevel: ProtoLogMessage.LogLevel = .debug

  var logDateTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LogCategory: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case transport // = 0
    case config // = 1
    case crash // = 2
    case `default` // = 3
    case fs // = 4
    case image // = 5
    case log // = 6
    case runTest // = 7
    case stats // = 8
    case dfu // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .transport
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transport
      case 1: self = .config
      case 2: self = .crash
      case 3: self = .default
      case 4: self = .fs
      case 5: self = .image
      case 6: self = .log
      case 7: self = .runTest
      case 8: self = .stats
      case 9: self = .dfu
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transport: return 0
      case .config: return 1
      case .crash: return 2
      case .default: return 3
      case .fs: return 4
      case .image: return 5
      case .log: return 6
      case .runTest: return 7
      case .stats: return 8
      case .dfu: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  enum LogLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case debug // = 0
    case verbose // = 1
    case info // = 2
    case application // = 3
    case warning // = 4
    case error // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .debug
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .debug
      case 1: self = .verbose
      case 2: self = .info
      case 3: self = .application
      case 4: self = .warning
      case 5: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .debug: return 0
      case .verbose: return 1
      case .info: return 2
      case .application: return 3
      case .warning: return 4
      case .error: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension ProtoLogMessage.LogCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ProtoLogMessage.LogCategory] = [
    .transport,
    .config,
    .crash,
    .default,
    .fs,
    .image,
    .log,
    .runTest,
    .stats,
    .dfu,
  ]
}

extension ProtoLogMessage.LogLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [ProtoLogMessage.LogLevel] = [
    .debug,
    .verbose,
    .info,
    .application,
    .warning,
    .error,
  ]
}

#endif  // swift(>=4.2)

struct ProtoMessageLiveLogEnabled {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var enabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ProtoUpdateCallArgument: @unchecked Sendable {}
extension ProtoError: @unchecked Sendable {}
extension Pair: @unchecked Sendable {}
extension ProtoUpdateWithImageCallArguments: @unchecked Sendable {}
extension ProtoUpdateStateChangesStreamArg: @unchecked Sendable {}
extension ProtoUpdateStateChanges: @unchecked Sendable {}
extension ProtoUpdateStateChanges.FirmwareUpgradeState: @unchecked Sendable {}
extension ProtoFirmwareUpgradeConfiguration: @unchecked Sendable {}
extension ProtoFirmwareUpgradeConfiguration.ImageUploadAlignment: @unchecked Sendable {}
extension ProtoProgressUpdateStreamArg: @unchecked Sendable {}
extension ProtoProgressUpdate: @unchecked Sendable {}
extension ProtoLogMessageStreamArg: @unchecked Sendable {}
extension ProtoLogMessage: @unchecked Sendable {}
extension ProtoLogMessage.LogCategory: @unchecked Sendable {}
extension ProtoLogMessage.LogLevel: @unchecked Sendable {}
extension ProtoMessageLiveLogEnabled: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProtoUpdateCallArgument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoUpdateCallArgument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_uuid"),
    2: .standard(proto: "firmware_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.firmwareData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    if !self.firmwareData.isEmpty {
      try visitor.visitSingularBytesField(value: self.firmwareData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoUpdateCallArgument, rhs: ProtoUpdateCallArgument) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.firmwareData != rhs.firmwareData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localizedDescription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localizedDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localizedDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.localizedDescription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoError, rhs: ProtoError) -> Bool {
    if lhs.localizedDescription != rhs.localizedDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Pair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Pair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.key != 0 {
      try visitor.visitSingularInt32Field(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Pair, rhs: Pair) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoUpdateWithImageCallArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoUpdateWithImageCallArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_uuid"),
    2: .same(proto: "images"),
    3: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 2)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoUpdateWithImageCallArguments, rhs: ProtoUpdateWithImageCallArguments) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.images != rhs.images {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoUpdateStateChangesStreamArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoUpdateStateChangesStreamArg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "done"),
    3: .same(proto: "error"),
    4: .same(proto: "updateStateChanges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateStateChanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updateStateChanges {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoUpdateStateChangesStreamArg, rhs: ProtoUpdateStateChangesStreamArg) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.done != rhs.done {return false}
    if lhs._error != rhs._error {return false}
    if lhs._updateStateChanges != rhs._updateStateChanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoUpdateStateChanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoUpdateStateChanges"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oldState"),
    2: .same(proto: "newState"),
    3: .same(proto: "canceled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.oldState) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.newState) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canceled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oldState != .none {
      try visitor.visitSingularEnumField(value: self.oldState, fieldNumber: 1)
    }
    if self.newState != .none {
      try visitor.visitSingularEnumField(value: self.newState, fieldNumber: 2)
    }
    if self.canceled != false {
      try visitor.visitSingularBoolField(value: self.canceled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoUpdateStateChanges, rhs: ProtoUpdateStateChanges) -> Bool {
    if lhs.oldState != rhs.oldState {return false}
    if lhs.newState != rhs.newState {return false}
    if lhs.canceled != rhs.canceled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoUpdateStateChanges.FirmwareUpgradeState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "VALIDATE"),
    2: .same(proto: "UPLOAD"),
    3: .same(proto: "TEST"),
    4: .same(proto: "RESET"),
    5: .same(proto: "CONFIRM"),
    6: .same(proto: "SUCCESS"),
    7: .same(proto: "REQUEST_MCU_MGR_PARAMETERS"),
    8: .same(proto: "ERASE_APP_SETTINGS"),
  ]
}

extension ProtoFirmwareUpgradeConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoFirmwareUpgradeConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "estimatedSwapTimeMs"),
    2: .same(proto: "eraseAppSettings"),
    3: .same(proto: "pipelineDepth"),
    4: .same(proto: "byteAlignment"),
    5: .same(proto: "reassemblyBufferSize"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.estimatedSwapTimeMs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.eraseAppSettings) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pipelineDepth) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.byteAlignment) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.reassemblyBufferSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.estimatedSwapTimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.estimatedSwapTimeMs, fieldNumber: 1)
    }
    if self.eraseAppSettings != false {
      try visitor.visitSingularBoolField(value: self.eraseAppSettings, fieldNumber: 2)
    }
    if self.pipelineDepth != 0 {
      try visitor.visitSingularInt64Field(value: self.pipelineDepth, fieldNumber: 3)
    }
    if self.byteAlignment != .disabled {
      try visitor.visitSingularEnumField(value: self.byteAlignment, fieldNumber: 4)
    }
    if self.reassemblyBufferSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.reassemblyBufferSize, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoFirmwareUpgradeConfiguration, rhs: ProtoFirmwareUpgradeConfiguration) -> Bool {
    if lhs.estimatedSwapTimeMs != rhs.estimatedSwapTimeMs {return false}
    if lhs.eraseAppSettings != rhs.eraseAppSettings {return false}
    if lhs.pipelineDepth != rhs.pipelineDepth {return false}
    if lhs.byteAlignment != rhs.byteAlignment {return false}
    if lhs.reassemblyBufferSize != rhs.reassemblyBufferSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoFirmwareUpgradeConfiguration.ImageUploadAlignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "TWO_BYTE"),
    2: .same(proto: "FOUR_BYTE"),
    3: .same(proto: "EIGHT_BYTE"),
    4: .same(proto: "SIXTEEN_BYTE"),
  ]
}

extension ProtoProgressUpdateStreamArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoProgressUpdateStreamArg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "done"),
    3: .same(proto: "error"),
    4: .same(proto: "progressUpdate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._progressUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._progressUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoProgressUpdateStreamArg, rhs: ProtoProgressUpdateStreamArg) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.done != rhs.done {return false}
    if lhs._error != rhs._error {return false}
    if lhs._progressUpdate != rhs._progressUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoProgressUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoProgressUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytesSent"),
    2: .same(proto: "imageSize"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bytesSent) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.imageSize) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 1)
    }
    if self.imageSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.imageSize, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoProgressUpdate, rhs: ProtoProgressUpdate) -> Bool {
    if lhs.bytesSent != rhs.bytesSent {return false}
    if lhs.imageSize != rhs.imageSize {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoLogMessageStreamArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoLogMessageStreamArg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "done"),
    3: .same(proto: "error"),
    4: .same(proto: "protoLogMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.protoLogMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.protoLogMessage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.protoLogMessage, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoLogMessageStreamArg, rhs: ProtoLogMessageStreamArg) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.done != rhs.done {return false}
    if lhs._error != rhs._error {return false}
    if lhs.protoLogMessage != rhs.protoLogMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoLogMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoLogMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "logCategory"),
    3: .same(proto: "logLevel"),
    4: .same(proto: "logDateTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.logCategory) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.logLevel) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.logDateTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.logCategory != .transport {
      try visitor.visitSingularEnumField(value: self.logCategory, fieldNumber: 2)
    }
    if self.logLevel != .debug {
      try visitor.visitSingularEnumField(value: self.logLevel, fieldNumber: 3)
    }
    if self.logDateTime != 0 {
      try visitor.visitSingularInt64Field(value: self.logDateTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoLogMessage, rhs: ProtoLogMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.logCategory != rhs.logCategory {return false}
    if lhs.logLevel != rhs.logLevel {return false}
    if lhs.logDateTime != rhs.logDateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoLogMessage.LogCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSPORT"),
    1: .same(proto: "CONFIG"),
    2: .same(proto: "CRASH"),
    3: .same(proto: "DEFAULT"),
    4: .same(proto: "FS"),
    5: .same(proto: "IMAGE"),
    6: .same(proto: "LOG"),
    7: .same(proto: "RUN_TEST"),
    8: .same(proto: "STATS"),
    9: .same(proto: "DFU"),
  ]
}

extension ProtoLogMessage.LogLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEBUG"),
    1: .same(proto: "VERBOSE"),
    2: .same(proto: "INFO"),
    3: .same(proto: "APPLICATION"),
    4: .same(proto: "WARNING"),
    5: .same(proto: "ERROR"),
  ]
}

extension ProtoMessageLiveLogEnabled: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoMessageLiveLogEnabled"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoMessageLiveLogEnabled, rhs: ProtoMessageLiveLogEnabled) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
