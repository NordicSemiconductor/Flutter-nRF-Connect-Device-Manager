// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: lib/proto/flutter_mcu.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Flutter call arguments
struct ProtoUpdateCallArgument: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceUuid: String = String()

  var hash: Data {
    get {return _hash ?? Data()}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var firmwareData: Data = Data()

  var configuration: ProtoFirmwareUpgradeConfiguration {
    get {return _configuration ?? ProtoFirmwareUpgradeConfiguration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: Data? = nil
  fileprivate var _configuration: ProtoFirmwareUpgradeConfiguration? = nil
}

struct ProtoError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var localizedDescription: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ProtoImage: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var image: Int32 = 0

  var slot: Int32 {
    get {return _slot ?? 0}
    set {_slot = newValue}
  }
  /// Returns true if `slot` has been explicitly set.
  var hasSlot: Bool {return self._slot != nil}
  /// Clears the value of `slot`. Subsequent reads from it will return its default value.
  mutating func clearSlot() {self._slot = nil}

  var hash: Data {
    get {return _hash ?? Data()}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _slot: Int32? = nil
  fileprivate var _hash: Data? = nil
}

struct ProtoUpdateWithImageCallArguments: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceUuid: String = String()

  var images: [ProtoImage] = []

  var configuration: ProtoFirmwareUpgradeConfiguration {
    get {return _configuration ?? ProtoFirmwareUpgradeConfiguration()}
    set {_configuration = newValue}
  }
  /// Returns true if `configuration` has been explicitly set.
  var hasConfiguration: Bool {return self._configuration != nil}
  /// Clears the value of `configuration`. Subsequent reads from it will return its default value.
  mutating func clearConfiguration() {self._configuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _configuration: ProtoFirmwareUpgradeConfiguration? = nil
}

/// STATE
struct ProtoUpdateStateChangesStreamArg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var done: Bool = false

  var error: ProtoError {
    get {return _error ?? ProtoError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var updateStateChanges: ProtoUpdateStateChanges {
    get {return _updateStateChanges ?? ProtoUpdateStateChanges()}
    set {_updateStateChanges = newValue}
  }
  /// Returns true if `updateStateChanges` has been explicitly set.
  var hasUpdateStateChanges: Bool {return self._updateStateChanges != nil}
  /// Clears the value of `updateStateChanges`. Subsequent reads from it will return its default value.
  mutating func clearUpdateStateChanges() {self._updateStateChanges = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: ProtoError? = nil
  fileprivate var _updateStateChanges: ProtoUpdateStateChanges? = nil
}

struct ProtoUpdateStateChanges: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oldState: ProtoUpdateStateChanges.FirmwareUpgradeState = .none

  var newState: ProtoUpdateStateChanges.FirmwareUpgradeState = .none

  var canceled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum FirmwareUpgradeState: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case none // = 0
    case validate // = 1
    case upload // = 2
    case test // = 3
    case reset // = 4
    case confirm // = 5
    case success // = 6
    case requestMcuMgrParameters // = 7
    case eraseAppSettings // = 8
    case bootloaderInfo // = 9
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .validate
      case 2: self = .upload
      case 3: self = .test
      case 4: self = .reset
      case 5: self = .confirm
      case 6: self = .success
      case 7: self = .requestMcuMgrParameters
      case 8: self = .eraseAppSettings
      case 9: self = .bootloaderInfo
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .validate: return 1
      case .upload: return 2
      case .test: return 3
      case .reset: return 4
      case .confirm: return 5
      case .success: return 6
      case .requestMcuMgrParameters: return 7
      case .eraseAppSettings: return 8
      case .bootloaderInfo: return 9
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [ProtoUpdateStateChanges.FirmwareUpgradeState] = [
      .none,
      .validate,
      .upload,
      .test,
      .reset,
      .confirm,
      .success,
      .requestMcuMgrParameters,
      .eraseAppSettings,
      .bootloaderInfo,
    ]

  }

  init() {}
}

struct ProtoFirmwareUpgradeConfiguration: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var estimatedSwapTimeMs: Int64 = 0

  var eraseAppSettings: Bool = false

  var pipelineDepth: Int64 = 0

  var byteAlignment: ProtoFirmwareUpgradeConfiguration.ImageUploadAlignment = .disabled

  var reassemblyBufferSize: UInt64 = 0

  var firmwareUpgradeMode: ProtoFirmwareUpgradeConfiguration.FirmwareUpgradeMode = .testOnly

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ImageUploadAlignment: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case disabled // = 0
    case twoByte // = 1
    case fourByte // = 2
    case eightByte // = 3
    case sixteenByte // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .disabled
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .disabled
      case 1: self = .twoByte
      case 2: self = .fourByte
      case 3: self = .eightByte
      case 4: self = .sixteenByte
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .disabled: return 0
      case .twoByte: return 1
      case .fourByte: return 2
      case .eightByte: return 3
      case .sixteenByte: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [ProtoFirmwareUpgradeConfiguration.ImageUploadAlignment] = [
      .disabled,
      .twoByte,
      .fourByte,
      .eightByte,
      .sixteenByte,
    ]

  }

  enum FirmwareUpgradeMode: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case testOnly // = 0
    case confirmOnly // = 1
    case testAndConfirm // = 2
    case uploadOnly // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .testOnly
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .testOnly
      case 1: self = .confirmOnly
      case 2: self = .testAndConfirm
      case 3: self = .uploadOnly
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .testOnly: return 0
      case .confirmOnly: return 1
      case .testAndConfirm: return 2
      case .uploadOnly: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [ProtoFirmwareUpgradeConfiguration.FirmwareUpgradeMode] = [
      .testOnly,
      .confirmOnly,
      .testAndConfirm,
      .uploadOnly,
    ]

  }

  init() {}
}

struct ProtoProgressUpdateStreamArg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var done: Bool = false

  var error: ProtoError {
    get {return _error ?? ProtoError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var progressUpdate: ProtoProgressUpdate {
    get {return _progressUpdate ?? ProtoProgressUpdate()}
    set {_progressUpdate = newValue}
  }
  /// Returns true if `progressUpdate` has been explicitly set.
  var hasProgressUpdate: Bool {return self._progressUpdate != nil}
  /// Clears the value of `progressUpdate`. Subsequent reads from it will return its default value.
  mutating func clearProgressUpdate() {self._progressUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: ProtoError? = nil
  fileprivate var _progressUpdate: ProtoProgressUpdate? = nil
}

struct ProtoProgressUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bytesSent: UInt64 = 0

  var imageSize: UInt64 = 0

  var timestamp: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// LOGS
struct ProtoLogMessageStreamArg: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var done: Bool = false

  var error: ProtoError {
    get {return _error ?? ProtoError()}
    set {_error = newValue}
  }
  /// Returns true if `error` has been explicitly set.
  var hasError: Bool {return self._error != nil}
  /// Clears the value of `error`. Subsequent reads from it will return its default value.
  mutating func clearError() {self._error = nil}

  var protoLogMessage: ProtoLogMessage {
    get {return _protoLogMessage ?? ProtoLogMessage()}
    set {_protoLogMessage = newValue}
  }
  /// Returns true if `protoLogMessage` has been explicitly set.
  var hasProtoLogMessage: Bool {return self._protoLogMessage != nil}
  /// Clears the value of `protoLogMessage`. Subsequent reads from it will return its default value.
  mutating func clearProtoLogMessage() {self._protoLogMessage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _error: ProtoError? = nil
  fileprivate var _protoLogMessage: ProtoLogMessage? = nil
}

struct ProtoLogMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var logCategory: ProtoLogMessage.LogCategory = .transport

  var logLevel: ProtoLogMessage.LogLevel = .debug

  var logDateTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum LogCategory: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case transport // = 0
    case config // = 1
    case crash // = 2
    case `default` // = 3
    case fs // = 4
    case image // = 5
    case log // = 6
    case runTest // = 7
    case stats // = 8
    case dfu // = 9
    case shell // = 10
    case suit // = 11
    case UNRECOGNIZED(Int)

    init() {
      self = .transport
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .transport
      case 1: self = .config
      case 2: self = .crash
      case 3: self = .default
      case 4: self = .fs
      case 5: self = .image
      case 6: self = .log
      case 7: self = .runTest
      case 8: self = .stats
      case 9: self = .dfu
      case 10: self = .shell
      case 11: self = .suit
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .transport: return 0
      case .config: return 1
      case .crash: return 2
      case .default: return 3
      case .fs: return 4
      case .image: return 5
      case .log: return 6
      case .runTest: return 7
      case .stats: return 8
      case .dfu: return 9
      case .shell: return 10
      case .suit: return 11
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [ProtoLogMessage.LogCategory] = [
      .transport,
      .config,
      .crash,
      .default,
      .fs,
      .image,
      .log,
      .runTest,
      .stats,
      .dfu,
      .shell,
      .suit,
    ]

  }

  enum LogLevel: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case debug // = 0
    case verbose // = 1
    case info // = 2
    case application // = 3
    case warning // = 4
    case error // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .debug
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .debug
      case 1: self = .verbose
      case 2: self = .info
      case 3: self = .application
      case 4: self = .warning
      case 5: self = .error
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .debug: return 0
      case .verbose: return 1
      case .info: return 2
      case .application: return 3
      case .warning: return 4
      case .error: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [ProtoLogMessage.LogLevel] = [
      .debug,
      .verbose,
      .info,
      .application,
      .warning,
      .error,
    ]

  }

  init() {}
}

struct ProtoReadLogCallArguments: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var clearLogs_p: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ProtoReadMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var protoLogMessage: [ProtoLogMessage] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// IMAGE MANAGER
struct ProtoListImagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var existing: Bool = false

  var images: [ProtoImageSlot] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ProtoImageSlot: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var image: UInt64 = 0

  var slot: UInt64 = 0

  var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var hash: Data = Data()

  var bootable: Bool = false

  var pending: Bool = false

  var confirmed: Bool = false

  var active: Bool = false

  var permanent: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ProtoUpdateCallArgument: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoUpdateCallArgument"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_uuid"),
    2: .same(proto: "hash"),
    3: .standard(proto: "firmware_data"),
    4: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._hash) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.firmwareData) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    try { if let v = self._hash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    if !self.firmwareData.isEmpty {
      try visitor.visitSingularBytesField(value: self.firmwareData, fieldNumber: 3)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoUpdateCallArgument, rhs: ProtoUpdateCallArgument) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs._hash != rhs._hash {return false}
    if lhs.firmwareData != rhs.firmwareData {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "localizedDescription"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.localizedDescription) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.localizedDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.localizedDescription, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoError, rhs: ProtoError) -> Bool {
    if lhs.localizedDescription != rhs.localizedDescription {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoImage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoImage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "slot"),
    3: .same(proto: "hash"),
    4: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.image) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self._slot) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._hash) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.image != 0 {
      try visitor.visitSingularInt32Field(value: self.image, fieldNumber: 1)
    }
    try { if let v = self._slot {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hash {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoImage, rhs: ProtoImage) -> Bool {
    if lhs.image != rhs.image {return false}
    if lhs._slot != rhs._slot {return false}
    if lhs._hash != rhs._hash {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoUpdateWithImageCallArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoUpdateWithImageCallArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_uuid"),
    2: .same(proto: "images"),
    3: .same(proto: "configuration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceUuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._configuration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.deviceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceUuid, fieldNumber: 1)
    }
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 2)
    }
    try { if let v = self._configuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoUpdateWithImageCallArguments, rhs: ProtoUpdateWithImageCallArguments) -> Bool {
    if lhs.deviceUuid != rhs.deviceUuid {return false}
    if lhs.images != rhs.images {return false}
    if lhs._configuration != rhs._configuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoUpdateStateChangesStreamArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoUpdateStateChangesStreamArg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "done"),
    3: .same(proto: "error"),
    4: .same(proto: "updateStateChanges"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateStateChanges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updateStateChanges {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoUpdateStateChangesStreamArg, rhs: ProtoUpdateStateChangesStreamArg) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.done != rhs.done {return false}
    if lhs._error != rhs._error {return false}
    if lhs._updateStateChanges != rhs._updateStateChanges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoUpdateStateChanges: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoUpdateStateChanges"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "oldState"),
    2: .same(proto: "newState"),
    3: .same(proto: "canceled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.oldState) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.newState) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.canceled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oldState != .none {
      try visitor.visitSingularEnumField(value: self.oldState, fieldNumber: 1)
    }
    if self.newState != .none {
      try visitor.visitSingularEnumField(value: self.newState, fieldNumber: 2)
    }
    if self.canceled != false {
      try visitor.visitSingularBoolField(value: self.canceled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoUpdateStateChanges, rhs: ProtoUpdateStateChanges) -> Bool {
    if lhs.oldState != rhs.oldState {return false}
    if lhs.newState != rhs.newState {return false}
    if lhs.canceled != rhs.canceled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoUpdateStateChanges.FirmwareUpgradeState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "VALIDATE"),
    2: .same(proto: "UPLOAD"),
    3: .same(proto: "TEST"),
    4: .same(proto: "RESET"),
    5: .same(proto: "CONFIRM"),
    6: .same(proto: "SUCCESS"),
    7: .same(proto: "REQUEST_MCU_MGR_PARAMETERS"),
    8: .same(proto: "ERASE_APP_SETTINGS"),
    9: .same(proto: "BOOTLOADER_INFO"),
  ]
}

extension ProtoFirmwareUpgradeConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoFirmwareUpgradeConfiguration"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "estimatedSwapTimeMs"),
    2: .same(proto: "eraseAppSettings"),
    3: .same(proto: "pipelineDepth"),
    4: .same(proto: "byteAlignment"),
    5: .same(proto: "reassemblyBufferSize"),
    6: .same(proto: "firmwareUpgradeMode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.estimatedSwapTimeMs) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.eraseAppSettings) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.pipelineDepth) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.byteAlignment) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.reassemblyBufferSize) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.firmwareUpgradeMode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.estimatedSwapTimeMs != 0 {
      try visitor.visitSingularInt64Field(value: self.estimatedSwapTimeMs, fieldNumber: 1)
    }
    if self.eraseAppSettings != false {
      try visitor.visitSingularBoolField(value: self.eraseAppSettings, fieldNumber: 2)
    }
    if self.pipelineDepth != 0 {
      try visitor.visitSingularInt64Field(value: self.pipelineDepth, fieldNumber: 3)
    }
    if self.byteAlignment != .disabled {
      try visitor.visitSingularEnumField(value: self.byteAlignment, fieldNumber: 4)
    }
    if self.reassemblyBufferSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.reassemblyBufferSize, fieldNumber: 5)
    }
    if self.firmwareUpgradeMode != .testOnly {
      try visitor.visitSingularEnumField(value: self.firmwareUpgradeMode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoFirmwareUpgradeConfiguration, rhs: ProtoFirmwareUpgradeConfiguration) -> Bool {
    if lhs.estimatedSwapTimeMs != rhs.estimatedSwapTimeMs {return false}
    if lhs.eraseAppSettings != rhs.eraseAppSettings {return false}
    if lhs.pipelineDepth != rhs.pipelineDepth {return false}
    if lhs.byteAlignment != rhs.byteAlignment {return false}
    if lhs.reassemblyBufferSize != rhs.reassemblyBufferSize {return false}
    if lhs.firmwareUpgradeMode != rhs.firmwareUpgradeMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoFirmwareUpgradeConfiguration.ImageUploadAlignment: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISABLED"),
    1: .same(proto: "TWO_BYTE"),
    2: .same(proto: "FOUR_BYTE"),
    3: .same(proto: "EIGHT_BYTE"),
    4: .same(proto: "SIXTEEN_BYTE"),
  ]
}

extension ProtoFirmwareUpgradeConfiguration.FirmwareUpgradeMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEST_ONLY"),
    1: .same(proto: "CONFIRM_ONLY"),
    2: .same(proto: "TEST_AND_CONFIRM"),
    3: .same(proto: "UPLOAD_ONLY"),
  ]
}

extension ProtoProgressUpdateStreamArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoProgressUpdateStreamArg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "done"),
    3: .same(proto: "error"),
    4: .same(proto: "progressUpdate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._progressUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._progressUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoProgressUpdateStreamArg, rhs: ProtoProgressUpdateStreamArg) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.done != rhs.done {return false}
    if lhs._error != rhs._error {return false}
    if lhs._progressUpdate != rhs._progressUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoProgressUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoProgressUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bytesSent"),
    2: .same(proto: "imageSize"),
    3: .same(proto: "timestamp"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.bytesSent) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.imageSize) }()
      case 3: try { try decoder.decodeSingularDoubleField(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.bytesSent != 0 {
      try visitor.visitSingularUInt64Field(value: self.bytesSent, fieldNumber: 1)
    }
    if self.imageSize != 0 {
      try visitor.visitSingularUInt64Field(value: self.imageSize, fieldNumber: 2)
    }
    if self.timestamp.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoProgressUpdate, rhs: ProtoProgressUpdate) -> Bool {
    if lhs.bytesSent != rhs.bytesSent {return false}
    if lhs.imageSize != rhs.imageSize {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoLogMessageStreamArg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoLogMessageStreamArg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "done"),
    3: .same(proto: "error"),
    4: .same(proto: "protoLogMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.done) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._error) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._protoLogMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.done != false {
      try visitor.visitSingularBoolField(value: self.done, fieldNumber: 2)
    }
    try { if let v = self._error {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._protoLogMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoLogMessageStreamArg, rhs: ProtoLogMessageStreamArg) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.done != rhs.done {return false}
    if lhs._error != rhs._error {return false}
    if lhs._protoLogMessage != rhs._protoLogMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoLogMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoLogMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "logCategory"),
    3: .same(proto: "logLevel"),
    4: .same(proto: "logDateTime"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.logCategory) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.logLevel) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.logDateTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.logCategory != .transport {
      try visitor.visitSingularEnumField(value: self.logCategory, fieldNumber: 2)
    }
    if self.logLevel != .debug {
      try visitor.visitSingularEnumField(value: self.logLevel, fieldNumber: 3)
    }
    if self.logDateTime != 0 {
      try visitor.visitSingularInt64Field(value: self.logDateTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoLogMessage, rhs: ProtoLogMessage) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.logCategory != rhs.logCategory {return false}
    if lhs.logLevel != rhs.logLevel {return false}
    if lhs.logDateTime != rhs.logDateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoLogMessage.LogCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRANSPORT"),
    1: .same(proto: "CONFIG"),
    2: .same(proto: "CRASH"),
    3: .same(proto: "DEFAULT"),
    4: .same(proto: "FS"),
    5: .same(proto: "IMAGE"),
    6: .same(proto: "LOG"),
    7: .same(proto: "RUN_TEST"),
    8: .same(proto: "STATS"),
    9: .same(proto: "DFU"),
    10: .same(proto: "SHELL"),
    11: .same(proto: "SUIT"),
  ]
}

extension ProtoLogMessage.LogLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEBUG"),
    1: .same(proto: "VERBOSE"),
    2: .same(proto: "INFO"),
    3: .same(proto: "APPLICATION"),
    4: .same(proto: "WARNING"),
    5: .same(proto: "ERROR"),
  ]
}

extension ProtoReadLogCallArguments: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoReadLogCallArguments"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "clearLogs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.clearLogs_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.clearLogs_p != false {
      try visitor.visitSingularBoolField(value: self.clearLogs_p, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReadLogCallArguments, rhs: ProtoReadLogCallArguments) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.clearLogs_p != rhs.clearLogs_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoReadMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoReadMessagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "protoLogMessage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.protoLogMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if !self.protoLogMessage.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.protoLogMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoReadMessagesResponse, rhs: ProtoReadMessagesResponse) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.protoLogMessage != rhs.protoLogMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoListImagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoListImagesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
    2: .same(proto: "existing"),
    3: .same(proto: "images"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.existing) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.images) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    if self.existing != false {
      try visitor.visitSingularBoolField(value: self.existing, fieldNumber: 2)
    }
    if !self.images.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.images, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoListImagesResponse, rhs: ProtoListImagesResponse) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.existing != rhs.existing {return false}
    if lhs.images != rhs.images {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ProtoImageSlot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ProtoImageSlot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "image"),
    2: .same(proto: "slot"),
    3: .same(proto: "version"),
    4: .same(proto: "hash"),
    5: .same(proto: "bootable"),
    6: .same(proto: "pending"),
    7: .same(proto: "confirmed"),
    8: .same(proto: "active"),
    9: .same(proto: "permanent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.image) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.slot) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._version) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.hash) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.bootable) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.pending) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.confirmed) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.active) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.permanent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.image != 0 {
      try visitor.visitSingularUInt64Field(value: self.image, fieldNumber: 1)
    }
    if self.slot != 0 {
      try visitor.visitSingularUInt64Field(value: self.slot, fieldNumber: 2)
    }
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    if self.bootable != false {
      try visitor.visitSingularBoolField(value: self.bootable, fieldNumber: 5)
    }
    if self.pending != false {
      try visitor.visitSingularBoolField(value: self.pending, fieldNumber: 6)
    }
    if self.confirmed != false {
      try visitor.visitSingularBoolField(value: self.confirmed, fieldNumber: 7)
    }
    if self.active != false {
      try visitor.visitSingularBoolField(value: self.active, fieldNumber: 8)
    }
    if self.permanent != false {
      try visitor.visitSingularBoolField(value: self.permanent, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ProtoImageSlot, rhs: ProtoImageSlot) -> Bool {
    if lhs.image != rhs.image {return false}
    if lhs.slot != rhs.slot {return false}
    if lhs._version != rhs._version {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.bootable != rhs.bootable {return false}
    if lhs.pending != rhs.pending {return false}
    if lhs.confirmed != rhs.confirmed {return false}
    if lhs.active != rhs.active {return false}
    if lhs.permanent != rhs.permanent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
